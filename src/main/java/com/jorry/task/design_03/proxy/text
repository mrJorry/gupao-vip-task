作用：通过委托人办事情，一个类代表另一个类的功能。是为了加以控制。


1. 静态代理
一个人只能委托某一个人做某一件事情，目标产生了限制


2. 动态代理：必须依赖接口
多个人可以委托某一个人做某一件事情，目标没有限制，任何人都可以委托代理

实现原理：（通过接口的方法反射出来，然后动态生成方法，实现覆盖）
｛
    1. 拿到被代理的引用，并且获取它的所有接口（反射获取）
    2. JDK Proxy类重新生成一个新的类，实现了被代理类所有接口的方法
    3. 动态生成 Java 代码，把增强逻辑加入到新生成代码中。
    4. 编译生成新的 Java 代理的 class 文件。
    5. 加载并重新运行新的 Class，得到类就是全新类。
｝


jdkproxy：（动态实现）实现 InvocationHandler
jdkProxy

cglib：（动态继承）实现 MethodInterceptor





spring中的代理选择原则
    1. 当Bean有实现接口时，Spring就会用JDK动态代理
    2. 当Bean没有实现接口时，Spring选择CGlig
    3. Spring可以通过配置强制使用CGlib，只需要Spring的配置文件中加入
    <aop:aspectj-autoproxy proxy-targer-class="true" />

优点：
    1. 代理模式能将代理对象与真实被调用的目标对象分离
    2. 一定程度上降低了系统的耦合程度，易于扩展
    3. 代理可以起到保护目标对象的作用
    4. 增强目标对象的职责

缺点：
    1. 代理模式会造成系统设计中类的数量
    2. 在客户端增加一个代理对象，会造成请求速度变慢
    3. 增加系统的复杂度