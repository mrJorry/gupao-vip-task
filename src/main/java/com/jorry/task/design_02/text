内部类执行逻辑
-> 在类加载的时候，内部类并不初始化。等在类名点内部类的时候，此时才会加载，并且静态类只会加载一次。



单例模式的只是重点总结
1.私有化构造器
2.保证多线程的安全
3.延迟加载
4.防止序列化和反序列化破坏单例
5.防止反射攻击


饿汉
    优点:绝对线程安全
    缺点:浪费空间，占着茅坑不拉屎
    做法:
        1.直接new
        2.在static块中new

懒汉
    优点:节省内存空间
    缺点:需要程序员自己解决线程问题
    做法:
        1.双重校验锁(dlc) + volatile
        2.内部类
            利用静态内部类默认不加载特性
            反射可以破坏

注册式单例
    1.枚举
        真·单例无双
        反射源码:对枚举做了剔除。不可用反射实例出枚举。
        利用 枚举名+枚举量名 注册在jvm中
    2.容器类型

序列化
    ObjectInputStream,ObjectOutputstream可以破坏
    覆写readResolve()方法

ThreadLocal
    线程内安全



原型模式：是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
        调用者不需要知道任何创建细节，不调用构造函数

使用场景：
    1. 类初始化消耗资源较多
    2. new 产生的一个对象需要非常繁琐的过程（数据准备、访问权限）
    3. 构造函数比较复杂
    4. 循环体中生产大量对象时

原型模式：
    原型模式就是如何快速构建对象的方法总结，简单工厂将get, set 封装到某个方法中

    JDK提供的实现，Cloneable接口，实现快速复制

    spring 中 scope="prototype", scope="singleto"

1. 浅克隆
克隆只克隆地址，并不一定是值
-> 创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。

2. 深克隆
克隆只克隆值，不克隆引用地址
-> 创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。